<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <style>
        body {
            background-color: white;
            padding: 100px;
            width: 1000px;
            margin: auto;
            text-align: left;
            font-weight: 300;
            font-family: 'Open Sans', sans-serif;
            color: #121212;
        }

        h1, h2, h3, h4 {
            font-family: 'Source Sans Pro', sans-serif;
        }

        kbd {
            color: #121212;
        }
    </style>
    <title>CS 184 Path Tracer</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet" />

    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            }
        };
    </script>
    <script id="MathJax-script" async=async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
    </script>

</head>


<body>

    <h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2023</h1>
    <h1 align="middle">Project 3-1: Path Tracer</h1>
    <h2 align="middle">Chaomin Li, Zhiqi Yan</h2>

    <!-- Add Website URL -->
    <h2 align="middle">Website URL: <a href="https://zhaominl.github.io/project-webpage-qq360/proj3-1/index.html">LINK</a></h2>

    <br /><br />

        <div>

            <h2 align="middle">Overview</h2>
            <p>
                In this project, we explored how ray tracing works. We learned about generating rays, ray object intersection calculation, BVH acceleration, direct illumination,
                global illumination, and adaptive sampling. We learned about how rendering speed can be improved using bounding box checking with the help of BVH tree construction,
                how scene objects can be rendered differently when we specify the number of bounces allowed. The process of ray tracing becomes familiar to us after working on this project
                and with the help of visualizating our work with the GUI.
            </p>
            <br />

            <h2 align="middle">Part 1: Ray Generation and Scene Intersection (20 Points)</h2>
            <!-- Walk through the ray generation and primitive intersection parts of the rendering pipeline.
            Explain the triangle intersection algorithm you implemented in your own words.
            Show images with normal shading for a few small .dae files. -->

            <h3>
                Walk through the ray generation and primitive intersection parts of the rendering pipeline.
            </h3>
            <p>
                YOUR RESPONSE GOES HERE
            </p>
            <br />

            <h3>
                Explain the triangle intersection algorithm you implemented in your own words.
            </h3>
            <p>
                YOUR RESPONSE GOES HERE
            </p>
            <br />

            <h3>
                Show images with normal shading for a few small .dae files.
            </h3>
            <!-- Example of including multiple figures -->
            <div align="middle">
                <table style="width:100%">
                    <tr align="center">
                        <td>
                            <img src="img/your_file.png" align="middle" width="400px" />
                            <figcaption>example1.dae</figcaption>
                        </td>
                        <td>
                            <img src="img/your_file.png" align="middle" width="400px" />
                            <figcaption>example2.dae</figcaption>
                        </td>
                    </tr>
                    <tr align="center">
                        <td>
                            <img src="img/your_file.png" align="middle" width="400px" />
                            <figcaption>example3.dae</figcaption>
                        </td>
                        <td>
                            <img src="img/your_file.png" align="middle" width="400px" />
                            <figcaption>example4.dae</figcaption>
                        </td>
                    </tr>
                </table>
            </div>
            <br />


            <h2 align="middle">Part 2: Bounding Volume Hierarchy (20 Points)</h2>
            <!-- Walk through your BVH construction algorithm. Explain the heuristic you chose for picking the splitting point.
            Show images with normal shading for a few large .dae files that you can only render with BVH acceleration.
            Compare rendering times on a few scenes with moderately complex geometries with and without BVH acceleration. Present your results in a one-paragraph analysis. -->

            <h3>
                Walk through your BVH construction algorithm. Explain the heuristic you chose for picking the splitting point.
            </h3>
            <p>
                The algorithm construct the BVH like a tree datatype where all nodes stores a bounding box data that covers all primitive inside the box.
                Specifically, all internal node has non-empty left and right child, and all leaf node has non-empty start and end iterator that points to
                all primitives inside the associated bounding box. \n

                The BVH tree is constructed using recursion. By checking the number of primitives inside the current bounding box,
                if it is a leaf node (number of primitives is small enough), we assign primitive iterator properly and return.
                Otherwise, we split the bounding box via a split axis, classify each primitive to either left bounding box or right bounding box based on their centroid,
                and make these bounding box left and right child of the current node and perform the same construction on these children recursively. \n

                The spliting heuristic we used is that we find the average centroid of all primitives. Tested on each split axis (x,y,z axis) with split point using the average controid,
                calculate bounding Volume per primitive on both left and right bounding box and sum them up, whatever axis that yield the smallest bounding volume per primitive sumed is the
                ideal axis to split. We then use that axis to split and use the average controid on that axis as splitting point.
            </p>

            <h3>
                Show images with normal shading for a few large .dae files that you can only render with BVH acceleration.
            </h3>
            <!-- Example of including multiple figures -->
            <div align="middle">
                <table style="width:100%">
                    <tr align="center">
                        <td>
                            <img src="img/blob.png" align="middle" width="400px" />
                            <figcaption>blob.dae</figcaption>
                        </td>
                        <td>
                            <img src="img/beast.png" align="middle" width="400px" />
                            <figcaption>beast.dae</figcaption>
                        </td>
                    </tr>
                    <tr align="center">
                        <td>
                            <img src="img/maxplanck.png" align="middle" width="400px" />
                            <figcaption>maxplanck.dae</figcaption>
                        </td>
                        <td>
                            <img src="img/CBlucy.png" align="middle" width="400px" />
                            <figcaption>CBlucy.dae</figcaption>
                        </td>
                    </tr>
                </table>
            </div>
            <br />

            <h3>
                Compare rendering times on a few scenes with moderately complex geometries with and without BVH acceleration. Present your results in a one-paragraph analysis.
            </h3>
            <p>
                When rendering the "meshedit/maxplanck.dae", it took 60s to complete without BVH acceleration, and 0.08s with BVH acceleration.
                When rendering the "sky/CBlucy.dae", it took 136s to complete without BVH acceleration, and 0.053s with BVH acceleration.
                It's clearly obvious that with BVH we do not have to test every signle primitive for each ray, and thus save us much time when rendering.
            </p>
            <br />

            <h2 align="middle">Part 3: Direct Illumination (20 Points)</h2>
            <!-- Walk through both implementations of the direct lighting function.
            Show some images rendered with both implementations of the direct lighting function.
            Focus on one particular scene with at least one area light and compare the noise levels in soft shadows when rendering with 1, 4, 16, and 64 light rays (the -l flag) and with 1 sample per pixel (the -s flag) using light sampling, not uniform hemisphere sampling.
            Compare the results between uniform hemisphere sampling and lighting sampling in a one-paragraph analysis. -->

            <h3>
                Walk through both implementations of the direct lighting function.
            </h3>
            <p>
                YOUR RESPONSE GOES HERE
            </p>

            <h3>
                Show some images rendered with both implementations of the direct lighting function.
            </h3>
            <!-- Example of including multiple figures -->
            <div align="middle">
                <table style="width:100%">
                    <!-- Header -->
                    <tr align="center">
                        <th>
                            <b>Uniform Hemisphere Sampling</b>
                        </th>
                        <th>
                            <b>Light Sampling</b>
                        </th>
                    </tr>
                    <br />
                    <tr align="center">
                        <td>
                            <img src="img/your_file.png" align="middle" width="400px" />
                            <figcaption>example1.dae</figcaption>
                        </td>
                        <td>
                            <img src="img/your_file.png" align="middle" width="400px" />
                            <figcaption>example1.dae</figcaption>
                        </td>
                    </tr>
                    <br />
                    <tr align="center">
                        <td>
                            <img src="img/your_file.png" align="middle" width="400px" />
                            <figcaption>example2.dae</figcaption>
                        </td>
                        <td>
                            <img src="img/your_file.png" align="middle" width="400px" />
                            <figcaption>example2.dae</figcaption>
                        </td>
                    </tr>
                    <br />
                </table>
            </div>
            <br />

            <h3>
                Focus on one particular scene with at least one area light and compare the noise levels in <b>soft shadows</b> when rendering with 1, 4, 16, and 64 light rays (the -l flag) and with 1 sample per pixel (the -s flag) using light sampling, <b>not</b> uniform hemisphere sampling.
            </h3>
            <!-- Example of including multiple figures -->
            <div align="middle">
                <table style="width:100%">
                    <tr align="center">
                        <td>
                            <img src="img/your_file.png" align="middle" width="200px" />
                            <figcaption>1 Light Ray (example1.dae)</figcaption>
                        </td>
                        <td>
                            <img src="img/your_file.png" align="middle" width="200px" />
                            <figcaption>4 Light Rays (example1.dae)</figcaption>
                        </td>
                    </tr>
                    <tr align="center">
                        <td>
                            <img src="img/your_file.png" align="middle" width="200px" />
                            <figcaption>16 Light Rays (example1.dae)</figcaption>
                        </td>
                        <td>
                            <img src="img/your_file.png" align="middle" width="200px" />
                            <figcaption>64 Light Rays (example1.dae)</figcaption>
                        </td>
                    </tr>
                </table>
            </div>
            <p>
                YOUR EXPLANATION GOES HERE
            </p>
            <br />

            <h3>
                Compare the results between uniform hemisphere sampling and lighting sampling in a one-paragraph analysis.
            </h3>
            <p>
                YOUR RESPONSE GOES HERE
            </p>
            <br />


            <h2 align="middle">Part 4: Global Illumination (20 Points)</h2>
            <!-- Walk through your implementation of the indirect lighting function.
            Show some images rendered with global (direct and indirect) illumination. Use 1024 samples per pixel.
            Pick one scene and compare rendered views first with only direct illumination, then only indirect illumination. Use 1024 samples per pixel. (You will have to edit PathTracer::at_least_one_bounce_radiance(...) in your code to generate these views.)
            For CBbunny.dae, compare rendered views with max_ray_depth set to 0, 1, 2, 3, and 100 (the -m flag). Use 1024 samples per pixel.
            Pick one scene and compare rendered views with various sample-per-pixel rates, including at least 1, 2, 4, 8, 16, 64, and 1024. Use 4 light rays.
            You will probably want to use the instructional machines for the above renders in order to not burn up your own computer for hours. -->

            <h3>
                Walk through your implementation of the indirect lighting function.
            </h3>
            <p>
                This is a recursive function. For a given incident light ray and an intersection point, we can caluculate its direct one bounce lighting at the intersection point using function from part3.
                Next, we sample the incoming ray at this point with pdf associated with this ray. We trace this incoming ray to scene objects to see if it intersects with anything and find the intersection
                point if so. We can calculate the indrect lighting like in direct illumination using Monte Carlo estimator for irradiance with radiance calculated from recursion and pdf we got from "sample_f".
                The global illumination at the intersection point is the sum of one bounce lighting and indirect lighting we traced through the scene.
                We stop the infinite recursion with a probability presetted like Russian Roulette.
            </p>
            <br />

            <h3>
                Show some images rendered with global (direct and indirect) illumination. Use 1024 samples per pixel.
            </h3>
            <!-- Example of including multiple figures -->
            <div align="middle">
                <table style="width:100%">
                    <tr align="center">
                        <td>
                            <img src="img/spheres.png" align="middle" width="400px" />
                            <figcaption>CBspheres_lambertian.dae</figcaption>
                        </td>
                        <td>
                            <img src="img/CBbunny.png" align="middle" width="400px" />
                            <figcaption>CBbunny.dae</figcaption>
                        </td>
                    </tr>
                </table>
            </div>
            <br />

            <h3>
                Pick one scene and compare rendered views first with only direct illumination, then only indirect illumination. Use 1024 samples per pixel. (You will have to edit PathTracer::at_least_one_bounce_radiance(...) in your code to generate these views.)
            </h3>
            <!-- Example of including multiple figures -->
            <div align="middle">
                <table style="width:100%">
                    <tr align="center">
                        <td>
                            <img src="img/spheres_direct.png" align="middle" width="400px" />
                            <figcaption>Only direct illumination (CBspheres_lambertian.dae)</figcaption>
                        </td>
                        <td>
                            <img src="img/spheres_indirect.png" align="middle" width="400px" />
                            <figcaption>Only indirect illumination (CBspheres_lambertian.dae)</figcaption>
                        </td>
                    </tr>
                </table>
            </div>
            <br />
            <p>
                The direct illumination comes from only zero bounce and one bounce lighting. The indirect illumination comes from at least two bounces of lighting.
            </p>
            <br />

            <h3>
                For CBbunny.dae, compare rendered views with max_ray_depth set to 0, 1, 2, 3, and 100 (the -m flag). Use 1024 samples per pixel.
            </h3>
            <!-- Example of including multiple figures -->
            <div align="middle">
                <table style="width:100%">
                    <tr align="center">
                        <td>
                            <img src="img/CBbunny_0.png" align="middle" width="400px" />
                            <figcaption>max_ray_depth = 0 (CBbunny.dae)</figcaption>
                        </td>
                        <td>
                            <img src="img/CBbunny_1.png" align="middle" width="400px" />
                            <figcaption>max_ray_depth = 1 (CBbunny.dae)</figcaption>
                        </td>
                    </tr>
                    <tr align="center">
                        <td>
                            <img src="img/CBbunny_2.png" align="middle" width="400px" />
                            <figcaption>max_ray_depth = 2 (CBbunny.dae)</figcaption>
                        </td>
                        <td>
                            <img src="img/CBbunny_3.png" align="middle" width="400px" />
                            <figcaption>max_ray_depth = 3 (CBbunny.dae)</figcaption>
                        </td>
                    </tr>
                    <tr align="center">
                        <td>
                            <img src="img/CBbunny_100.png" align="middle" width="400px" />
                            <figcaption>max_ray_depth = 100 (CBbunny.dae)</figcaption>
                        </td>
                    </tr>
                </table>
            </div>
            <br />
            <p>
                With more bounces allowed, we will have more realistice scene rendered. For example, the ceiling becomes brighter and the shadow of bunny becomes smaller.
            </p>
            <br />

            <h3>
                Pick one scene and compare rendered views with various sample-per-pixel rates, including at least 1, 2, 4, 8, 16, 64, and 1024. Use 4 light rays.
            </h3>
            <!-- Example of including multiple figures -->
            <div align="middle">
                <table style="width:100%">
                    <tr align="center">
                        <td>
                            <img src="img/spheres_s1.png" align="middle" width="400px" />
                            <figcaption>1 sample per pixel (CBspheres_lambertian.dae)</figcaption>
                        </td>
                        <td>
                            <img src="img/spheres_s2.png" align="middle" width="400px" />
                            <figcaption>2 samples per pixel (CBspheres_lambertian.dae)</figcaption>
                        </td>
                    </tr>
                    <tr align="center">
                        <td>
                            <img src="img/spheres_s4.png" align="middle" width="400px" />
                            <figcaption>4 samples per pixel (CBspheres_lambertian.dae)</figcaption>
                        </td>
                        <td>
                            <img src="img/spheres_s8.png" align="middle" width="400px" />
                            <figcaption>8 samples per pixel (CBspheres_lambertian.dae)</figcaption>
                        </td>
                    </tr>
                    <tr align="center">
                        <td>
                            <img src="img/spheres_s16.png" align="middle" width="400px" />
                            <figcaption>16 samples per pixel (CBspheres_lambertian.dae)</figcaption>
                        </td>
                        <td>
                            <img src="img/spheres_s64.png" align="middle" width="400px" />
                            <figcaption>64 samples per pixel (CBspheres_lambertian.dae)</figcaption>
                        </td>
                    </tr>
                    <tr align="center">
                        <td>
                            <img src="img/spheres_s1024.png" align="middle" width="400px" />
                            <figcaption>1024 samples per pixel (CBspheres_lambertian.dae)</figcaption>
                        </td>
                    </tr>
                </table>
            </div>
            <br />
            <p>
                The more samples-per-pixel we have, the less rendering artifact will we get (Specifically those black dots).
            </p>
            <br />


            <h2 align="middle">Part 5: Adaptive Sampling (20 Points)</h2>
            <!-- Explain adaptive sampling. Walk through your implementation of the adaptive sampling.
            Pick one scene and render it with at least 2048 samples per pixel. Show a good sampling rate image with clearly visible differences in sampling rate over various regions and pixels. Include both your sample rate image, which shows your how your adaptive sampling changes depending on which part of the image you are rendering, and your noise-free rendered result. Use 1 sample per light and at least 5 for max ray depth. -->

            <h3>
                Explain adaptive sampling. Walk through your implementation of the adaptive sampling.
            </h3>
            <p>
                YOUR RESPONSE GOES HERE
            </p>
            <br />

            <h3>
                Pick two scenes and render them with at least 2048 samples per pixel. Show a good sampling rate image with clearly visible differences in sampling rate over various regions and pixels. Include both your sample rate image, which shows your how your adaptive sampling changes depending on which part of the image you are rendering, and your noise-free rendered result. Use 1 sample per light and at least 5 for max ray depth.
            </h3>
            <!-- Example of including multiple figures -->
            <div align="middle">
                <table style="width:100%">
                    <tr align="center">
                        <td>
                            <img src="img/your_file.png" align="middle" width="400px" />
                            <figcaption>Rendered image (example1.dae)</figcaption>
                        </td>
                        <td>
                            <img src="img/your_file.png" align="middle" width="400px" />
                            <figcaption>Sample rate image (example1.dae)</figcaption>
                        </td>
                    </tr>
                    <tr align="center">
                        <td>
                            <img src="img/your_file.png" align="middle" width="400px" />
                            <figcaption>Rendered image (example2.dae)</figcaption>
                        </td>
                        <td>
                            <img src="img/your_file.png" align="middle" width="400px" />
                            <figcaption>Sample rate image (example2.dae)</figcaption>
                        </td>
                    </tr>
                </table>
            </div>
            <br />


        </div>


    </o>


</body>
</html>
